/*import 'dart:io';

import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter/material.dart';
import 'package:flutter_salesman_module/api/login_api.dart';
import 'package:flutter_salesman_module/models/autogenerate_model.dart';
import 'package:flutter_salesman_module/utils/services/global_methods.dart';

class ChannelDataProvider extends ChangeNotifier {
  Autogenerated? _channelData;
  bool _isLoading = false;
  String? _error;

  Autogenerated? get channelData => _channelData;
  bool get isLoading => _isLoading;
  String? get error => _error;

  Future<void> fetchChannelData(
    String username,
    String token,
    String date,
    String userId,
    VoidCallback onTokenExpired,
    BuildContext context,
  ) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    // Check internet connectivity
    final connectivityResult = await Connectivity().checkConnectivity();
    if (connectivityResult == ConnectivityResult.none) {
      _error = "No Internet Connection";
      GlobalMethods.showApiErrorMessage(
        context,
        "Connection Error",
        "Please check your internet connection.",
      );
      _isLoading = false;
      notifyListeners();
      return;
    }

    try {
      date = GlobalMethods.getFormattedGmtDate();
      _channelData = await LoginApi.getChannelData(
        username,
        token,
        date,
        userId,
      );
    } catch (e) {
      final errorMessage = e.toString();
      if (e is SocketException ||
          errorMessage.contains("Failed host lookup") ||
          errorMessage.contains(
            "OS Error: No address associated with hostname",
          )) {
        _error = "No Internet Connection";
        GlobalMethods.showApiErrorMessage(
          context,
          "Connection Error",
          "Please check your internet connection.",
        );
      } else if (errorMessage.contains(
        "Authorization has been denied for this request.",
      )) {
        final message = GlobalMethods.extractErrorMessage(errorMessage);
        GlobalMethods.showApiErrorMessage(context, "Error", message);
        onTokenExpired();
        _error = message;
      } else {
        _error = errorMessage;
      }

      _isLoading = false;
      notifyListeners();
      return;
    }

    _isLoading = false;
    notifyListeners();
  }
}
*/

import 'dart:io';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter/material.dart';
import 'package:flutter_salesman_module/api/login_api.dart';
import 'package:flutter_salesman_module/models/autogenerate_model.dart';
import 'package:flutter_salesman_module/utils/services/global_methods.dart';

class ChannelDataProvider extends ChangeNotifier {
  Autogenerated? _channelData;
  bool _isLoading = false;
  String? _error;

  /// Full list (all customers with cluster info)
  List<Map<String, dynamic>> _allCustomersWithCluster = [];

  /// Filtered list (for UI)
  List<Map<String, dynamic>> _filteredCustomers = [];

  Autogenerated? get channelData => _channelData;
  bool get isLoading => _isLoading;
  String? get error => _error;

  /// Exposed filtered customers
  List<Map<String, dynamic>> get customersWithCluster => _filteredCustomers;

  Future<void> fetchChannelData(
    String username,
    String token,
    String date,
    String userId,
    VoidCallback onTokenExpired,
    BuildContext context,
  ) async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    // Check internet connectivity
    final connectivityResult = await Connectivity().checkConnectivity();
    if (connectivityResult == ConnectivityResult.none) {
      _error = "No Internet Connection";
      GlobalMethods.showApiErrorMessage(
        context,
        "Connection Error",
        "Please check your internet connection.",
      );
      _isLoading = false;
      notifyListeners();
      return;
    }

    try {
      date = GlobalMethods.getFormattedGmtDate();
      _channelData = await LoginApi.getChannelData(
        username,
        token,
        date,
        userId,
      );

      // Build customer list with cluster after API call
      _allCustomersWithCluster = [];
      final channels = _channelData?.channelsData ?? [];
      for (var channel in channels) {
        final customers = channel.customers ?? [];
        final hideCustomer = channel.hideCustomers ?? false;
        for (var customer in customers) {
          if (hideCustomer) continue;
          final hasProductMust =
              (channel.productMustItems?.isNotEmpty ?? false);
          final hasPriceMust = (channel.priceMustItems?.isNotEmpty ?? false);
          final hasPlaceMust = (channel.placeMustItems?.isNotEmpty ?? false);
          final hasPromoMust = (channel.promoMustItems?.isNotEmpty ?? false);

          final showProduct =
              hasProductMust &&
              (channel.productKPIFrequency ?? 0) >
                  (customer.productKPIVisits ?? 0);

          final showPrice =
              hasPriceMust &&
              (channel.priceKPIFrequency ?? 0) > (customer.priceKPIVisits ?? 0);

          final showPlace =
              hasPlaceMust &&
              (channel.placeKPIFrequency ?? 0) > (customer.placeKPIVisits ?? 0);

          final showPromo =
              hasPromoMust &&
              (channel.promoKPIFrequency ?? 0) > (customer.promoKPIVisits ?? 0);
          if (showProduct || showPrice || showPlace || showPromo) {
            _allCustomersWithCluster.add({
              'customer': customer,
              'cluster': channel.name,
              'channelId': channel.id,
              'productFrequency': channel.productKPIFrequency?.toInt(),
              'priceFrequency': channel.priceKPIFrequency?.toInt(),
              'placeFrequency': channel.placeKPIFrequency?.toInt(),
              'promoFrequency': channel.promoKPIFrequency?.toInt(),
              'ProductMustItems': channel.productMustItems,
              'PriceMustItems': channel.priceMustItems,
              'PlaceMustItems': channel.placeMustItems,
              'PromoMustItems': channel.promoMustItems,
              'isImageMandatory': channel.imagesMandatory ?? false,
              'showProduct': showProduct,
              'showPrice': showPrice,
              'showPlace': showPlace,
              'showPromo': showPromo,
            });
          }
        }
      }

      // Default filtered list = all
      _filteredCustomers = _allCustomersWithCluster;
    } catch (e) {
      final errorMessage = e.toString();
      if (e is SocketException ||
          errorMessage.contains("Failed host lookup") ||
          errorMessage.contains(
            "OS Error: No address associated with hostname",
          )) {
        _error = "No Internet Connection";
        GlobalMethods.showApiErrorMessage(
          context,
          "Connection Error",
          "Please check your internet connection.",
        );
      } else if (errorMessage.contains(
        "Authorization has been denied for this request.",
      )) {
        final message = GlobalMethods.extractErrorMessage(errorMessage);
        GlobalMethods.showApiErrorMessage(context, "Error", message);
        onTokenExpired();
        _error = message;
      } else {
        _error = errorMessage;
      }
    }

    _isLoading = false;
    notifyListeners();
  }

  /// üîç Search method
  void searchCustomer(String query) {
    if (query.isEmpty) {
      _filteredCustomers = _allCustomersWithCluster;
    } else {
      _filteredCustomers =
          _allCustomersWithCluster.where((data) {
            final customerName =
                (data['customer']?.name ?? '').toString().toLowerCase();
            final clusterName =
                (data['cluster'] ?? '').toString().toLowerCase();
            return customerName.contains(query.toLowerCase()) ||
                clusterName.contains(query.toLowerCase());
          }).toList();
    }
    notifyListeners();
  }
}
